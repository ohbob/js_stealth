import { packUInt32, packUInt16, unpackUInt32, unpackUInt16 } from './datatypes.js';
import { EventEmitter } from 'events';
import type { Socket } from 'net';
import { EVENTS } from '../constants.js';

const VERSION = [2, 7, 0, 0];
const PACKET_TYPE_RESULT = 1;
const PACKET_TYPE_TERMINATE = 2;
const PACKET_TYPE_PAUSE = 4;
const PACKET_TYPE_EVENT = 6;
const PACKET_TYPE_REQ_SCRIPT_PATH = 9;

const EVENTS_NAMES = EVENTS;

interface PendingPromise {
  resolve: (value: Buffer) => void;
  reject: (error: Error) => void;
  timeout: NodeJS.Timeout;
}

export class Protocol extends EventEmitter {
  socket: Socket;
  private _id: number;
  private _buffer: Buffer;
  pause: boolean;
  results: Map<number, Buffer>;
  pendingPromises: Map<number, PendingPromise>;
  callbacks: Map<number, (...args: any[]) => void>;

  constructor(socket: Socket) {
    super();
    this.socket = socket;
    this._id = 0;
    this._buffer = Buffer.alloc(0);
    this.pause = false;
    this.results = new Map();
    this.pendingPromises = new Map();
    this.callbacks = new Map();
    
    socket.on('data', (data: Buffer) => {
      this._onData(data);
    });
    socket.on('error', (err: Error) => this.emit('error', err));
    socket.on('close', () => this.emit('close'));
  }

  methodId(): number {
    this._id = (this._id + 1) % 65535;
    return this._id;
  }

  sendPacket(type: number, methodIndex: number, id: number, data: Buffer = Buffer.alloc(0)): void {
    const header = Buffer.concat([
      packUInt16(methodIndex),
      packUInt16(id)
    ]);
    const packet = Buffer.concat([header, data]);
    const size = packUInt32(packet.length);
    const fullPacket = Buffer.concat([size, packet]);
    
    const flushed = this.socket.write(fullPacket);
    
    if (!flushed) {
      console.warn(`Socket buffer full for method ${methodIndex}, id ${id}`);
    }
  }
  
  sendPacketsBatch(packets: Buffer[]): void {
    for (const packet of packets) {
      this.socket.write(packet);
    }
  }

  sendMethod(methodIndex: number, argData: Buffer, expectResult: boolean = false): number {
    if (methodIndex === 0) {
      return 0;
    }
    const id = expectResult ? this.methodId() : 0;
    this.sendPacket(PACKET_TYPE_RESULT, methodIndex, id, argData);
    return id;
  }

  private _onData(data: Buffer): void {
    this._buffer = Buffer.concat([this._buffer, data]);
    this._parseBuffer();
  }

  private _parseBuffer(): void {
    while (this._buffer.length >= 4) {
      const packetSize = unpackUInt32(this._buffer, 0);
      
      if (this._buffer.length < 4 + packetSize) {
        break;
      }
      
      const packet = this._buffer.slice(4, 4 + packetSize);
      this._buffer = this._buffer.slice(4 + packetSize);
      
      this._handlePacket(packet);
    }
  }

  private _handlePacket(packet: Buffer): void {
    if (packet.length < 4) return;
    
    const type = unpackUInt16(packet, 0);
    const subType = unpackUInt16(packet, 2);
    
    switch (type) {
      case PACKET_TYPE_RESULT:
        this._handleResult(subType, packet.slice(4));
        break;
      case PACKET_TYPE_TERMINATE:
        this.pause = true;
        break;
      case PACKET_TYPE_PAUSE:
        this.pause = true;
        break;
      case PACKET_TYPE_EVENT:
        this._handleEvent(subType, packet.slice(4));
        break;
      case PACKET_TYPE_REQ_SCRIPT_PATH:
        // Handle script path request
        break;
    }
  }

  private _handleResult(id: number, data: Buffer): void {
    this.results.set(id, data);
    const pending = this.pendingPromises.get(id);
    if (pending) {
      clearTimeout(pending.timeout);
      this.pendingPromises.delete(id);
      pending.resolve(data);
    }
  }

  private _handleEvent(eventIndex: number, data: Buffer): void {
    const callback = this.callbacks.get(eventIndex);
    if (callback) {
      try {
        callback(data);
      } catch (err) {
        this.emit('error', err);
      }
    }
    this.emit(EVENTS_NAMES[eventIndex] || `event${eventIndex}`, data);
  }

  async waitForResult(id: number, timeout: number = 1500): Promise<Buffer> {
    if (this.results.has(id)) {
      const result = this.results.get(id)!;
      this.results.delete(id);
      return result;
    }
    
    return new Promise((resolve, reject) => {
      const timeoutHandle = setTimeout(() => {
        this.pendingPromises.delete(id);
        reject(new Error(`Timeout waiting for result ${id}`));
      }, timeout);
      
      this.pendingPromises.set(id, {
        resolve: (data: Buffer) => {
          clearTimeout(timeoutHandle);
          resolve(data);
        },
        reject: (error: Error) => {
          clearTimeout(timeoutHandle);
          reject(error);
        },
        timeout: timeoutHandle
      });
    });
  }
  on(event: string, callback: (...args: any[]) => void): this {
    return super.on(event, callback);
  }

  processReceives(): void {
    if (this.socket.readable && !this.socket.destroyed) {
      let chunk: Buffer | null;
      while (null !== (chunk = this.socket.read())) {
        if (chunk && chunk.length > 0) {
          this._onData(chunk);
        }
      }
      if (this._buffer.length >= 4) {
        this._parseBuffer();
      }
    }
  }
}
